#pragma once

#include <cassert>

#include "sodium.h"

#include "keysqr.h"
#include "key-generation-options.hpp"
#include "generate-key.hpp"

class KeySqrCrypto {
private:
  inline static bool hasInitializedSodium = false;
  const KeySqr<Face> &keySqr;
  const KeyGenerationOptions &keyGenerationOptions;
public:

  KeySqrCrypto(
    const KeySqr<Face> &_keySqr,
    const KeyGenerationOptions &_keyGenerationOptions
  ) :
    keySqr(_keySqr),
    keyGenerationOptions(_keyGenerationOptions)
  {
    if (!hasInitializedSodium) {
      if (sodium_init() < 0) {
        throw "Could not initialize sodium";
        /* panic! the library couldn't be initialized, it is not safe to use */
      }
      hasInitializedSodium = true;
    }
  }

  
  const std::vector<unsigned char> generateKeyForApplicationUse(
  ) {
    std::vector<unsigned char> keyForApplicationUse(keyGenerationOptions.keyLengthInBytes);
    generateKey(
      keyForApplicationUse,
      keySqr,
      keyGenerationOptions,
      KeyGenerationOptionsJson::Purpose::ForApplicationUse
    );
    return keyForApplicationUse;
  }

  /**
   *
   * LibSodium's crypto_secretbox_easy construct isn't THAT easy.
   * The caller must store both the ciphertext AND a 24-byte nonce
   * (crypto_secretbox_NONCEBYTES = 24).
   * 
   * This seal operation outputs a _composite_ ciphertext containing the
   * nonce followed by the "secret box" ciphertext generated by LibSodium.
   * Since the "secret box" is 16 bytes longer than the message size
   * (crypto_secretbox_MACBYTES = 16),
   * the composite ciphertext is is 40 bytes longer than the message length
   * (24 for then nonce, plus the 16 added to create the secret box)
   */
  const std::vector<unsigned char> sealSymmetric(
    const unsigned char* message,
    const size_t messageLength
  ) {
    if (messageLength <= 0) {
      throw "Invalid message length";
    }
    const size_t compositeCiphertestLength =
      crypto_secretbox_NONCEBYTES + messageLength + crypto_secretbox_MACBYTES;
    std::vector<unsigned char> compositeCiphertext(compositeCiphertestLength);
    unsigned char* noncePtr = compositeCiphertext.data();
    unsigned char* secretBoxStartPtr = noncePtr + crypto_secretbox_NONCEBYTES;

    randombytes_buf(noncePtr, crypto_secretbox_NONCEBYTES);
    unsigned char keyForSymmetricKeySealedMessages[crypto_secretbox_KEYBYTES];
    try {
      generateKey(
        keyForSymmetricKeySealedMessages,
        crypto_secretbox_KEYBYTES,
        keySqr,
        keyGenerationOptions,
        KeyGenerationOptionsJson::Purpose::ForSymmetricKeySealedMessages
      );

      crypto_secretbox_easy(
        secretBoxStartPtr,
        message,
        messageLength,
        noncePtr,
        keyForSymmetricKeySealedMessages
      );
    } catch (...) {
      sodium_memzero(keyForSymmetricKeySealedMessages, crypto_secretbox_KEYBYTES);
      throw;
    }

    sodium_memzero(keyForSymmetricKeySealedMessages, crypto_secretbox_KEYBYTES);
    return compositeCiphertext;
  }

  const std::vector<unsigned char> unsealSymmetric(
    const unsigned char* compositeCiphertext,
    const size_t compositeCiphertestLength
  ) {
    if (compositeCiphertestLength <= (crypto_secretbox_MACBYTES + crypto_secretbox_NONCEBYTES)) {
      throw "Invalid message length";
    }
    const size_t messageLength = compositeCiphertestLength - (crypto_secretbox_MACBYTES + crypto_secretbox_NONCEBYTES);
    std::vector<unsigned char> plaintext(messageLength);
    const unsigned char* noncePtr = compositeCiphertext;
    const unsigned char* secretBoxStartPtr = noncePtr + crypto_secretbox_NONCEBYTES;

    unsigned char keyForSymmetricKeySealedMessages[crypto_secretbox_KEYBYTES];
    try {
      generateKey(
        keyForSymmetricKeySealedMessages,
        crypto_secretbox_KEYBYTES,
        keySqr,
        keyGenerationOptions,
        KeyGenerationOptionsJson::Purpose::ForSymmetricKeySealedMessages
      );

      crypto_secretbox_open_easy(
        plaintext.data(),
        secretBoxStartPtr,
        compositeCiphertestLength,
        noncePtr,
        keyForSymmetricKeySealedMessages
      );
    } catch (...) {
      sodium_memzero(keyForSymmetricKeySealedMessages, crypto_secretbox_KEYBYTES);
      throw;
    }

    sodium_memzero(keyForSymmetricKeySealedMessages, crypto_secretbox_KEYBYTES);
    return plaintext;
  }

  const std::vector<unsigned char> generateAndRevealPublicKey(
  ) {
    unsigned char keySeedForPublicKeySealedMesssages[crypto_box_SEEDBYTES];
    std::vector<unsigned char> pk(crypto_box_PUBLICKEYBYTES);
    unsigned char sk[crypto_box_SECRETKEYBYTES];

    try {
      generateKey(
        keySeedForPublicKeySealedMesssages,
        crypto_secretbox_KEYBYTES,
        keySqr,
        keyGenerationOptions,
        // There are two valid purposes for requesting a public key,
        // but we're always passing in a constant of one of those two valid options
        // to ensure the purpose matching requirement is enforced.
        keyGenerationOptions.purpose == KeyGenerationOptionsJson::Purpose::ForPublicKeySealedMesssages ?
          KeyGenerationOptionsJson::Purpose::ForPublicKeySealedMesssages :
          KeyGenerationOptionsJson::Purpose::ForPublicKeySealedMesssagesWithRestrictionsEnforcedPostDecryption
      );
      crypto_box_seed_keypair(pk.data(), sk, keySeedForPublicKeySealedMesssages);
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
      sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
    } catch (...) {
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
      sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
      throw;
    }

    return pk;
  }

  const std::vector<unsigned char> sealPublic(
    const unsigned char* message,
    const size_t messageLength,
    const std::vector<unsigned char> publicKey
  ) {
    unsigned char keySeedForPublicKeySealedMesssages[crypto_box_SEEDBYTES];
    if (publicKey.size() != crypto_box_PUBLICKEYBYTES) {
      throw "Invalid key size exception";
    }
    if (messageLength <= 0) {
      throw "Invalid message length";
    }
    const size_t ciphertextLength =
      messageLength + crypto_box_SEALBYTES;
    std::vector<unsigned char> ciphertext(ciphertextLength);

    crypto_box_seal(
      ciphertext.data(),
      message,
      messageLength,
      publicKey.data()
    );

    return ciphertext;
  }
  

  const std::vector<unsigned char> sealPublic(
    const unsigned char* message,
    const size_t messageLength
  ) {
    unsigned char keySeedForPublicKeySealedMesssages[crypto_box_SEEDBYTES];
    std::vector<unsigned char> publicKey(crypto_box_PUBLICKEYBYTES);
    unsigned char secretKey[crypto_box_SECRETKEYBYTES];
    std::vector<unsigned char> ciphertext;

    try {
      generateKey(
        keySeedForPublicKeySealedMesssages,
        crypto_secretbox_KEYBYTES,
        keySqr,
        keyGenerationOptions,
        KeyGenerationOptionsJson::Purpose::ForPublicKeySealedMesssages
      );
      crypto_box_seed_keypair(publicKey.data(), secretKey, keySeedForPublicKeySealedMesssages);
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);

      ciphertext = sealPublic(message, messageLength, publicKey);

    } catch (...) {
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
      sodium_memzero(secretKey, crypto_box_SECRETKEYBYTES);
      throw;
    }

    sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
    sodium_memzero(secretKey, crypto_box_SECRETKEYBYTES);
    return ciphertext;
  }
  
  const std::vector<unsigned char> unsealPublic(
    const unsigned char* ciphertext,
    const size_t ciphertextLength
  ) {
    unsigned char keySeedForPublicKeySealedMesssages[crypto_box_SEEDBYTES];
    unsigned char pk[crypto_box_PUBLICKEYBYTES];
    unsigned char sk[crypto_box_SECRETKEYBYTES];

    if (ciphertextLength <= crypto_box_SEALBYTES) {
      throw "Invalid message length";
    }
    const size_t plaintextLength =
      ciphertextLength -crypto_box_SEALBYTES;
    std::vector<unsigned char> plaintext(plaintextLength);

    try {
      generateKey(
        keySeedForPublicKeySealedMesssages,
        crypto_secretbox_KEYBYTES,
        keySqr,
        keyGenerationOptions,
        KeyGenerationOptionsJson::Purpose::ForPublicKeySealedMesssages
      );
      crypto_box_seed_keypair(pk, sk, keySeedForPublicKeySealedMesssages);
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);

      crypto_box_seal_open(
        plaintext.data(),
        ciphertext,
        ciphertextLength,
        pk,
        sk
      );

    } catch (...) {
      sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
      sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
      throw;
    }

    sodium_memzero(keySeedForPublicKeySealedMesssages, crypto_box_SEEDBYTES);
    sodium_memzero(sk, crypto_box_SECRETKEYBYTES);
    return plaintext;
  }

  
  const std::vector<unsigned char> seal(
    const unsigned char* message,
    const size_t messageLength
  ) {
    if (keyGenerationOptions.purpose == KeyGenerationOptionsJson::Purpose::ForSymmetricKeySealedMessages) {
      return sealSymmetric(message, messageLength);
    } else {
      return sealPublic(message, messageLength);
    }
  }

  const std::vector<unsigned char> seal(
    const std::vector<unsigned char> message
  ) {
    return seal(message.data(), message.size());
  }

  const std::vector<unsigned char> unseal(
    const unsigned char* ciphertext,
    const size_t ciphertextLength
  ) {
    if (keyGenerationOptions.purpose == KeyGenerationOptionsJson::Purpose::ForSymmetricKeySealedMessages) {
      return unsealSymmetric(ciphertext, ciphertextLength);
    } else {
      return unsealPublic(ciphertext, ciphertextLength);
    }
  }

  const std::vector<unsigned char> unseal(
    const std::vector<unsigned char> ciphertext
  ) {
    return unseal(ciphertext.data(), ciphertext.size());
  }

};
